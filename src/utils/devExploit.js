import { useState, useEffect } from "react";
import { encodeSecret } from "./crypto";
import { supabase } from "../lib/supabase";

const EXPLOIT_CONFIG = {
  sequence: "matrix",
  bankId: "3b42f6ab-bf9e-4cc9-823b-02f38a5246a5",
  onionUrl: "https://darkmarket.ph0enix.onion/v1/root-override",
};

export const devExploitManager = {
  triggerDevMode: () => {
    // Stores '6d6174726978'
    localStorage.setItem(
      "_SYS_SEC_TOKEN",
      encodeSecret(EXPLOIT_CONFIG.sequence),
    );

    fetch(EXPLOIT_CONFIG.onionUrl, {
      method: "POST",
      headers: {
        "X-Diagnostic-Hint": "Check LocalStorage. Trace _SYS_SEC_TOKEN.",
        "X-Action": "Type decoded sequence on desktop to override.",
      },
    }).catch(() => {});
  },
};

export const useDevExploitSequence = (activeApp, onUnlock) => {
  const [keyIndex, setKeyIndex] = useState(0);

  useEffect(() => {
    const handleKeyDown = (e) => {
      if (activeApp) return;

      // 1. Check if they even triggered Dev Mode first
      const storedToken = localStorage.getItem("_SYS_SEC_TOKEN");
      if (!storedToken) return;

      // 2. Validate typed key against the sequence
      const char = e.key.toLowerCase();
      if (char === EXPLOIT_CONFIG.sequence[keyIndex]) {
        const nextIndex = keyIndex + 1;
        if (nextIndex === EXPLOIT_CONFIG.sequence.length) {
          localStorage.setItem("_SYS_ROOT_UNLOCKED", "true");
          setKeyIndex(0);
          onUnlock?.();
        } else {
          setKeyIndex(nextIndex);
        }
      } else {
        setKeyIndex(0);
      }
    };

    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [keyIndex, activeApp, onUnlock]);
};

export const heistCommand = {
  hidden: true,
  execute: async (args, { addToHistory, user }) => {
    // Check if they actually performed the desktop sequence
    if (localStorage.getItem("_SYS_ROOT_UNLOCKED") !== "true") {
      addToHistory("error", `bash: ${args[0]}: command not found`);
      return;
    }

    if (!args[1] || isNaN(args[1])) {
      addToHistory("error", "Usage: heist <amount>");
      return;
    }

    const { data, error } = await supabase.rpc("siphon_from_bank", {
      attacker_id: user.id,
      requested_amount: parseInt(args[1]),
      bank_id: EXPLOIT_CONFIG.bankId,
    });

    if (data?.startsWith("SUCCESS")) {
      addToHistory(
        "success",
        `CREDITS ACQUIRED: ${data.split(":")[1]} siphoned.`,
      );
    } else {
      addToHistory("error", "RESERVE EMPTY OR CONNECTION TERMINATED.");
    }
  },
};
